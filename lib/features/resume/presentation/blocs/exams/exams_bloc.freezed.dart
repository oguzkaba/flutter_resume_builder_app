// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'exams_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ExamsEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getExams,
    required TResult Function(ExamsEntity examsEntity) addExams,
    required TResult Function(ExamsEntity examsEntity) updateExams,
    required TResult Function(int id) deleteExams,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getExams,
    TResult? Function(ExamsEntity examsEntity)? addExams,
    TResult? Function(ExamsEntity examsEntity)? updateExams,
    TResult? Function(int id)? deleteExams,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getExams,
    TResult Function(ExamsEntity examsEntity)? addExams,
    TResult Function(ExamsEntity examsEntity)? updateExams,
    TResult Function(int id)? deleteExams,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetExams value) getExams,
    required TResult Function(_AddExams value) addExams,
    required TResult Function(_UpdateExams value) updateExams,
    required TResult Function(_DeleteExams value) deleteExams,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetExams value)? getExams,
    TResult? Function(_AddExams value)? addExams,
    TResult? Function(_UpdateExams value)? updateExams,
    TResult? Function(_DeleteExams value)? deleteExams,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetExams value)? getExams,
    TResult Function(_AddExams value)? addExams,
    TResult Function(_UpdateExams value)? updateExams,
    TResult Function(_DeleteExams value)? deleteExams,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExamsEventCopyWith<$Res> {
  factory $ExamsEventCopyWith(
          ExamsEvent value, $Res Function(ExamsEvent) then) =
      _$ExamsEventCopyWithImpl<$Res, ExamsEvent>;
}

/// @nodoc
class _$ExamsEventCopyWithImpl<$Res, $Val extends ExamsEvent>
    implements $ExamsEventCopyWith<$Res> {
  _$ExamsEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$GetExamsImplCopyWith<$Res> {
  factory _$$GetExamsImplCopyWith(
          _$GetExamsImpl value, $Res Function(_$GetExamsImpl) then) =
      __$$GetExamsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetExamsImplCopyWithImpl<$Res>
    extends _$ExamsEventCopyWithImpl<$Res, _$GetExamsImpl>
    implements _$$GetExamsImplCopyWith<$Res> {
  __$$GetExamsImplCopyWithImpl(
      _$GetExamsImpl _value, $Res Function(_$GetExamsImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GetExamsImpl implements _GetExams {
  const _$GetExamsImpl();

  @override
  String toString() {
    return 'ExamsEvent.getExams()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetExamsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getExams,
    required TResult Function(ExamsEntity examsEntity) addExams,
    required TResult Function(ExamsEntity examsEntity) updateExams,
    required TResult Function(int id) deleteExams,
  }) {
    return getExams();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getExams,
    TResult? Function(ExamsEntity examsEntity)? addExams,
    TResult? Function(ExamsEntity examsEntity)? updateExams,
    TResult? Function(int id)? deleteExams,
  }) {
    return getExams?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getExams,
    TResult Function(ExamsEntity examsEntity)? addExams,
    TResult Function(ExamsEntity examsEntity)? updateExams,
    TResult Function(int id)? deleteExams,
    required TResult orElse(),
  }) {
    if (getExams != null) {
      return getExams();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetExams value) getExams,
    required TResult Function(_AddExams value) addExams,
    required TResult Function(_UpdateExams value) updateExams,
    required TResult Function(_DeleteExams value) deleteExams,
  }) {
    return getExams(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetExams value)? getExams,
    TResult? Function(_AddExams value)? addExams,
    TResult? Function(_UpdateExams value)? updateExams,
    TResult? Function(_DeleteExams value)? deleteExams,
  }) {
    return getExams?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetExams value)? getExams,
    TResult Function(_AddExams value)? addExams,
    TResult Function(_UpdateExams value)? updateExams,
    TResult Function(_DeleteExams value)? deleteExams,
    required TResult orElse(),
  }) {
    if (getExams != null) {
      return getExams(this);
    }
    return orElse();
  }
}

abstract class _GetExams implements ExamsEvent {
  const factory _GetExams() = _$GetExamsImpl;
}

/// @nodoc
abstract class _$$AddExamsImplCopyWith<$Res> {
  factory _$$AddExamsImplCopyWith(
          _$AddExamsImpl value, $Res Function(_$AddExamsImpl) then) =
      __$$AddExamsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ExamsEntity examsEntity});
}

/// @nodoc
class __$$AddExamsImplCopyWithImpl<$Res>
    extends _$ExamsEventCopyWithImpl<$Res, _$AddExamsImpl>
    implements _$$AddExamsImplCopyWith<$Res> {
  __$$AddExamsImplCopyWithImpl(
      _$AddExamsImpl _value, $Res Function(_$AddExamsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? examsEntity = null,
  }) {
    return _then(_$AddExamsImpl(
      null == examsEntity
          ? _value.examsEntity
          : examsEntity // ignore: cast_nullable_to_non_nullable
              as ExamsEntity,
    ));
  }
}

/// @nodoc

class _$AddExamsImpl implements _AddExams {
  const _$AddExamsImpl(this.examsEntity);

  @override
  final ExamsEntity examsEntity;

  @override
  String toString() {
    return 'ExamsEvent.addExams(examsEntity: $examsEntity)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddExamsImpl &&
            (identical(other.examsEntity, examsEntity) ||
                other.examsEntity == examsEntity));
  }

  @override
  int get hashCode => Object.hash(runtimeType, examsEntity);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddExamsImplCopyWith<_$AddExamsImpl> get copyWith =>
      __$$AddExamsImplCopyWithImpl<_$AddExamsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getExams,
    required TResult Function(ExamsEntity examsEntity) addExams,
    required TResult Function(ExamsEntity examsEntity) updateExams,
    required TResult Function(int id) deleteExams,
  }) {
    return addExams(examsEntity);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getExams,
    TResult? Function(ExamsEntity examsEntity)? addExams,
    TResult? Function(ExamsEntity examsEntity)? updateExams,
    TResult? Function(int id)? deleteExams,
  }) {
    return addExams?.call(examsEntity);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getExams,
    TResult Function(ExamsEntity examsEntity)? addExams,
    TResult Function(ExamsEntity examsEntity)? updateExams,
    TResult Function(int id)? deleteExams,
    required TResult orElse(),
  }) {
    if (addExams != null) {
      return addExams(examsEntity);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetExams value) getExams,
    required TResult Function(_AddExams value) addExams,
    required TResult Function(_UpdateExams value) updateExams,
    required TResult Function(_DeleteExams value) deleteExams,
  }) {
    return addExams(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetExams value)? getExams,
    TResult? Function(_AddExams value)? addExams,
    TResult? Function(_UpdateExams value)? updateExams,
    TResult? Function(_DeleteExams value)? deleteExams,
  }) {
    return addExams?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetExams value)? getExams,
    TResult Function(_AddExams value)? addExams,
    TResult Function(_UpdateExams value)? updateExams,
    TResult Function(_DeleteExams value)? deleteExams,
    required TResult orElse(),
  }) {
    if (addExams != null) {
      return addExams(this);
    }
    return orElse();
  }
}

abstract class _AddExams implements ExamsEvent {
  const factory _AddExams(final ExamsEntity examsEntity) = _$AddExamsImpl;

  ExamsEntity get examsEntity;
  @JsonKey(ignore: true)
  _$$AddExamsImplCopyWith<_$AddExamsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateExamsImplCopyWith<$Res> {
  factory _$$UpdateExamsImplCopyWith(
          _$UpdateExamsImpl value, $Res Function(_$UpdateExamsImpl) then) =
      __$$UpdateExamsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ExamsEntity examsEntity});
}

/// @nodoc
class __$$UpdateExamsImplCopyWithImpl<$Res>
    extends _$ExamsEventCopyWithImpl<$Res, _$UpdateExamsImpl>
    implements _$$UpdateExamsImplCopyWith<$Res> {
  __$$UpdateExamsImplCopyWithImpl(
      _$UpdateExamsImpl _value, $Res Function(_$UpdateExamsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? examsEntity = null,
  }) {
    return _then(_$UpdateExamsImpl(
      null == examsEntity
          ? _value.examsEntity
          : examsEntity // ignore: cast_nullable_to_non_nullable
              as ExamsEntity,
    ));
  }
}

/// @nodoc

class _$UpdateExamsImpl implements _UpdateExams {
  const _$UpdateExamsImpl(this.examsEntity);

  @override
  final ExamsEntity examsEntity;

  @override
  String toString() {
    return 'ExamsEvent.updateExams(examsEntity: $examsEntity)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateExamsImpl &&
            (identical(other.examsEntity, examsEntity) ||
                other.examsEntity == examsEntity));
  }

  @override
  int get hashCode => Object.hash(runtimeType, examsEntity);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateExamsImplCopyWith<_$UpdateExamsImpl> get copyWith =>
      __$$UpdateExamsImplCopyWithImpl<_$UpdateExamsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getExams,
    required TResult Function(ExamsEntity examsEntity) addExams,
    required TResult Function(ExamsEntity examsEntity) updateExams,
    required TResult Function(int id) deleteExams,
  }) {
    return updateExams(examsEntity);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getExams,
    TResult? Function(ExamsEntity examsEntity)? addExams,
    TResult? Function(ExamsEntity examsEntity)? updateExams,
    TResult? Function(int id)? deleteExams,
  }) {
    return updateExams?.call(examsEntity);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getExams,
    TResult Function(ExamsEntity examsEntity)? addExams,
    TResult Function(ExamsEntity examsEntity)? updateExams,
    TResult Function(int id)? deleteExams,
    required TResult orElse(),
  }) {
    if (updateExams != null) {
      return updateExams(examsEntity);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetExams value) getExams,
    required TResult Function(_AddExams value) addExams,
    required TResult Function(_UpdateExams value) updateExams,
    required TResult Function(_DeleteExams value) deleteExams,
  }) {
    return updateExams(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetExams value)? getExams,
    TResult? Function(_AddExams value)? addExams,
    TResult? Function(_UpdateExams value)? updateExams,
    TResult? Function(_DeleteExams value)? deleteExams,
  }) {
    return updateExams?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetExams value)? getExams,
    TResult Function(_AddExams value)? addExams,
    TResult Function(_UpdateExams value)? updateExams,
    TResult Function(_DeleteExams value)? deleteExams,
    required TResult orElse(),
  }) {
    if (updateExams != null) {
      return updateExams(this);
    }
    return orElse();
  }
}

abstract class _UpdateExams implements ExamsEvent {
  const factory _UpdateExams(final ExamsEntity examsEntity) = _$UpdateExamsImpl;

  ExamsEntity get examsEntity;
  @JsonKey(ignore: true)
  _$$UpdateExamsImplCopyWith<_$UpdateExamsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DeleteExamsImplCopyWith<$Res> {
  factory _$$DeleteExamsImplCopyWith(
          _$DeleteExamsImpl value, $Res Function(_$DeleteExamsImpl) then) =
      __$$DeleteExamsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int id});
}

/// @nodoc
class __$$DeleteExamsImplCopyWithImpl<$Res>
    extends _$ExamsEventCopyWithImpl<$Res, _$DeleteExamsImpl>
    implements _$$DeleteExamsImplCopyWith<$Res> {
  __$$DeleteExamsImplCopyWithImpl(
      _$DeleteExamsImpl _value, $Res Function(_$DeleteExamsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
  }) {
    return _then(_$DeleteExamsImpl(
      null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$DeleteExamsImpl implements _DeleteExams {
  const _$DeleteExamsImpl(this.id);

  @override
  final int id;

  @override
  String toString() {
    return 'ExamsEvent.deleteExams(id: $id)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteExamsImpl &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteExamsImplCopyWith<_$DeleteExamsImpl> get copyWith =>
      __$$DeleteExamsImplCopyWithImpl<_$DeleteExamsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getExams,
    required TResult Function(ExamsEntity examsEntity) addExams,
    required TResult Function(ExamsEntity examsEntity) updateExams,
    required TResult Function(int id) deleteExams,
  }) {
    return deleteExams(id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getExams,
    TResult? Function(ExamsEntity examsEntity)? addExams,
    TResult? Function(ExamsEntity examsEntity)? updateExams,
    TResult? Function(int id)? deleteExams,
  }) {
    return deleteExams?.call(id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getExams,
    TResult Function(ExamsEntity examsEntity)? addExams,
    TResult Function(ExamsEntity examsEntity)? updateExams,
    TResult Function(int id)? deleteExams,
    required TResult orElse(),
  }) {
    if (deleteExams != null) {
      return deleteExams(id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetExams value) getExams,
    required TResult Function(_AddExams value) addExams,
    required TResult Function(_UpdateExams value) updateExams,
    required TResult Function(_DeleteExams value) deleteExams,
  }) {
    return deleteExams(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetExams value)? getExams,
    TResult? Function(_AddExams value)? addExams,
    TResult? Function(_UpdateExams value)? updateExams,
    TResult? Function(_DeleteExams value)? deleteExams,
  }) {
    return deleteExams?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetExams value)? getExams,
    TResult Function(_AddExams value)? addExams,
    TResult Function(_UpdateExams value)? updateExams,
    TResult Function(_DeleteExams value)? deleteExams,
    required TResult orElse(),
  }) {
    if (deleteExams != null) {
      return deleteExams(this);
    }
    return orElse();
  }
}

abstract class _DeleteExams implements ExamsEvent {
  const factory _DeleteExams(final int id) = _$DeleteExamsImpl;

  int get id;
  @JsonKey(ignore: true)
  _$$DeleteExamsImplCopyWith<_$DeleteExamsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ExamsState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() examsLoading,
    required TResult Function(List<ExamsEntity> exams) examsSuccess,
    required TResult Function(String successMessage) successOnlyMessage,
    required TResult Function(String message) examsFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? examsLoading,
    TResult? Function(List<ExamsEntity> exams)? examsSuccess,
    TResult? Function(String successMessage)? successOnlyMessage,
    TResult? Function(String message)? examsFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? examsLoading,
    TResult Function(List<ExamsEntity> exams)? examsSuccess,
    TResult Function(String successMessage)? successOnlyMessage,
    TResult Function(String message)? examsFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_ExamsLoading value) examsLoading,
    required TResult Function(ExamsSuccess value) examsSuccess,
    required TResult Function(_SuccessOnlyMessage value) successOnlyMessage,
    required TResult Function(_ExamsFailure value) examsFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_ExamsLoading value)? examsLoading,
    TResult? Function(ExamsSuccess value)? examsSuccess,
    TResult? Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult? Function(_ExamsFailure value)? examsFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_ExamsLoading value)? examsLoading,
    TResult Function(ExamsSuccess value)? examsSuccess,
    TResult Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult Function(_ExamsFailure value)? examsFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExamsStateCopyWith<$Res> {
  factory $ExamsStateCopyWith(
          ExamsState value, $Res Function(ExamsState) then) =
      _$ExamsStateCopyWithImpl<$Res, ExamsState>;
}

/// @nodoc
class _$ExamsStateCopyWithImpl<$Res, $Val extends ExamsState>
    implements $ExamsStateCopyWith<$Res> {
  _$ExamsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$ExamsStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'ExamsState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() examsLoading,
    required TResult Function(List<ExamsEntity> exams) examsSuccess,
    required TResult Function(String successMessage) successOnlyMessage,
    required TResult Function(String message) examsFailure,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? examsLoading,
    TResult? Function(List<ExamsEntity> exams)? examsSuccess,
    TResult? Function(String successMessage)? successOnlyMessage,
    TResult? Function(String message)? examsFailure,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? examsLoading,
    TResult Function(List<ExamsEntity> exams)? examsSuccess,
    TResult Function(String successMessage)? successOnlyMessage,
    TResult Function(String message)? examsFailure,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_ExamsLoading value) examsLoading,
    required TResult Function(ExamsSuccess value) examsSuccess,
    required TResult Function(_SuccessOnlyMessage value) successOnlyMessage,
    required TResult Function(_ExamsFailure value) examsFailure,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_ExamsLoading value)? examsLoading,
    TResult? Function(ExamsSuccess value)? examsSuccess,
    TResult? Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult? Function(_ExamsFailure value)? examsFailure,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_ExamsLoading value)? examsLoading,
    TResult Function(ExamsSuccess value)? examsSuccess,
    TResult Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult Function(_ExamsFailure value)? examsFailure,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements ExamsState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$ExamsLoadingImplCopyWith<$Res> {
  factory _$$ExamsLoadingImplCopyWith(
          _$ExamsLoadingImpl value, $Res Function(_$ExamsLoadingImpl) then) =
      __$$ExamsLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ExamsLoadingImplCopyWithImpl<$Res>
    extends _$ExamsStateCopyWithImpl<$Res, _$ExamsLoadingImpl>
    implements _$$ExamsLoadingImplCopyWith<$Res> {
  __$$ExamsLoadingImplCopyWithImpl(
      _$ExamsLoadingImpl _value, $Res Function(_$ExamsLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ExamsLoadingImpl implements _ExamsLoading {
  const _$ExamsLoadingImpl();

  @override
  String toString() {
    return 'ExamsState.examsLoading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ExamsLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() examsLoading,
    required TResult Function(List<ExamsEntity> exams) examsSuccess,
    required TResult Function(String successMessage) successOnlyMessage,
    required TResult Function(String message) examsFailure,
  }) {
    return examsLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? examsLoading,
    TResult? Function(List<ExamsEntity> exams)? examsSuccess,
    TResult? Function(String successMessage)? successOnlyMessage,
    TResult? Function(String message)? examsFailure,
  }) {
    return examsLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? examsLoading,
    TResult Function(List<ExamsEntity> exams)? examsSuccess,
    TResult Function(String successMessage)? successOnlyMessage,
    TResult Function(String message)? examsFailure,
    required TResult orElse(),
  }) {
    if (examsLoading != null) {
      return examsLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_ExamsLoading value) examsLoading,
    required TResult Function(ExamsSuccess value) examsSuccess,
    required TResult Function(_SuccessOnlyMessage value) successOnlyMessage,
    required TResult Function(_ExamsFailure value) examsFailure,
  }) {
    return examsLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_ExamsLoading value)? examsLoading,
    TResult? Function(ExamsSuccess value)? examsSuccess,
    TResult? Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult? Function(_ExamsFailure value)? examsFailure,
  }) {
    return examsLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_ExamsLoading value)? examsLoading,
    TResult Function(ExamsSuccess value)? examsSuccess,
    TResult Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult Function(_ExamsFailure value)? examsFailure,
    required TResult orElse(),
  }) {
    if (examsLoading != null) {
      return examsLoading(this);
    }
    return orElse();
  }
}

abstract class _ExamsLoading implements ExamsState {
  const factory _ExamsLoading() = _$ExamsLoadingImpl;
}

/// @nodoc
abstract class _$$ExamsSuccessImplCopyWith<$Res> {
  factory _$$ExamsSuccessImplCopyWith(
          _$ExamsSuccessImpl value, $Res Function(_$ExamsSuccessImpl) then) =
      __$$ExamsSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<ExamsEntity> exams});
}

/// @nodoc
class __$$ExamsSuccessImplCopyWithImpl<$Res>
    extends _$ExamsStateCopyWithImpl<$Res, _$ExamsSuccessImpl>
    implements _$$ExamsSuccessImplCopyWith<$Res> {
  __$$ExamsSuccessImplCopyWithImpl(
      _$ExamsSuccessImpl _value, $Res Function(_$ExamsSuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? exams = null,
  }) {
    return _then(_$ExamsSuccessImpl(
      null == exams
          ? _value._exams
          : exams // ignore: cast_nullable_to_non_nullable
              as List<ExamsEntity>,
    ));
  }
}

/// @nodoc

class _$ExamsSuccessImpl implements ExamsSuccess {
  const _$ExamsSuccessImpl(final List<ExamsEntity> exams) : _exams = exams;

  final List<ExamsEntity> _exams;
  @override
  List<ExamsEntity> get exams {
    if (_exams is EqualUnmodifiableListView) return _exams;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_exams);
  }

  @override
  String toString() {
    return 'ExamsState.examsSuccess(exams: $exams)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExamsSuccessImpl &&
            const DeepCollectionEquality().equals(other._exams, _exams));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_exams));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExamsSuccessImplCopyWith<_$ExamsSuccessImpl> get copyWith =>
      __$$ExamsSuccessImplCopyWithImpl<_$ExamsSuccessImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() examsLoading,
    required TResult Function(List<ExamsEntity> exams) examsSuccess,
    required TResult Function(String successMessage) successOnlyMessage,
    required TResult Function(String message) examsFailure,
  }) {
    return examsSuccess(exams);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? examsLoading,
    TResult? Function(List<ExamsEntity> exams)? examsSuccess,
    TResult? Function(String successMessage)? successOnlyMessage,
    TResult? Function(String message)? examsFailure,
  }) {
    return examsSuccess?.call(exams);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? examsLoading,
    TResult Function(List<ExamsEntity> exams)? examsSuccess,
    TResult Function(String successMessage)? successOnlyMessage,
    TResult Function(String message)? examsFailure,
    required TResult orElse(),
  }) {
    if (examsSuccess != null) {
      return examsSuccess(exams);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_ExamsLoading value) examsLoading,
    required TResult Function(ExamsSuccess value) examsSuccess,
    required TResult Function(_SuccessOnlyMessage value) successOnlyMessage,
    required TResult Function(_ExamsFailure value) examsFailure,
  }) {
    return examsSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_ExamsLoading value)? examsLoading,
    TResult? Function(ExamsSuccess value)? examsSuccess,
    TResult? Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult? Function(_ExamsFailure value)? examsFailure,
  }) {
    return examsSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_ExamsLoading value)? examsLoading,
    TResult Function(ExamsSuccess value)? examsSuccess,
    TResult Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult Function(_ExamsFailure value)? examsFailure,
    required TResult orElse(),
  }) {
    if (examsSuccess != null) {
      return examsSuccess(this);
    }
    return orElse();
  }
}

abstract class ExamsSuccess implements ExamsState {
  const factory ExamsSuccess(final List<ExamsEntity> exams) =
      _$ExamsSuccessImpl;

  List<ExamsEntity> get exams;
  @JsonKey(ignore: true)
  _$$ExamsSuccessImplCopyWith<_$ExamsSuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SuccessOnlyMessageImplCopyWith<$Res> {
  factory _$$SuccessOnlyMessageImplCopyWith(_$SuccessOnlyMessageImpl value,
          $Res Function(_$SuccessOnlyMessageImpl) then) =
      __$$SuccessOnlyMessageImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String successMessage});
}

/// @nodoc
class __$$SuccessOnlyMessageImplCopyWithImpl<$Res>
    extends _$ExamsStateCopyWithImpl<$Res, _$SuccessOnlyMessageImpl>
    implements _$$SuccessOnlyMessageImplCopyWith<$Res> {
  __$$SuccessOnlyMessageImplCopyWithImpl(_$SuccessOnlyMessageImpl _value,
      $Res Function(_$SuccessOnlyMessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? successMessage = null,
  }) {
    return _then(_$SuccessOnlyMessageImpl(
      null == successMessage
          ? _value.successMessage
          : successMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SuccessOnlyMessageImpl implements _SuccessOnlyMessage {
  const _$SuccessOnlyMessageImpl(this.successMessage);

  @override
  final String successMessage;

  @override
  String toString() {
    return 'ExamsState.successOnlyMessage(successMessage: $successMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuccessOnlyMessageImpl &&
            (identical(other.successMessage, successMessage) ||
                other.successMessage == successMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, successMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SuccessOnlyMessageImplCopyWith<_$SuccessOnlyMessageImpl> get copyWith =>
      __$$SuccessOnlyMessageImplCopyWithImpl<_$SuccessOnlyMessageImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() examsLoading,
    required TResult Function(List<ExamsEntity> exams) examsSuccess,
    required TResult Function(String successMessage) successOnlyMessage,
    required TResult Function(String message) examsFailure,
  }) {
    return successOnlyMessage(successMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? examsLoading,
    TResult? Function(List<ExamsEntity> exams)? examsSuccess,
    TResult? Function(String successMessage)? successOnlyMessage,
    TResult? Function(String message)? examsFailure,
  }) {
    return successOnlyMessage?.call(successMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? examsLoading,
    TResult Function(List<ExamsEntity> exams)? examsSuccess,
    TResult Function(String successMessage)? successOnlyMessage,
    TResult Function(String message)? examsFailure,
    required TResult orElse(),
  }) {
    if (successOnlyMessage != null) {
      return successOnlyMessage(successMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_ExamsLoading value) examsLoading,
    required TResult Function(ExamsSuccess value) examsSuccess,
    required TResult Function(_SuccessOnlyMessage value) successOnlyMessage,
    required TResult Function(_ExamsFailure value) examsFailure,
  }) {
    return successOnlyMessage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_ExamsLoading value)? examsLoading,
    TResult? Function(ExamsSuccess value)? examsSuccess,
    TResult? Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult? Function(_ExamsFailure value)? examsFailure,
  }) {
    return successOnlyMessage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_ExamsLoading value)? examsLoading,
    TResult Function(ExamsSuccess value)? examsSuccess,
    TResult Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult Function(_ExamsFailure value)? examsFailure,
    required TResult orElse(),
  }) {
    if (successOnlyMessage != null) {
      return successOnlyMessage(this);
    }
    return orElse();
  }
}

abstract class _SuccessOnlyMessage implements ExamsState {
  const factory _SuccessOnlyMessage(final String successMessage) =
      _$SuccessOnlyMessageImpl;

  String get successMessage;
  @JsonKey(ignore: true)
  _$$SuccessOnlyMessageImplCopyWith<_$SuccessOnlyMessageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ExamsFailureImplCopyWith<$Res> {
  factory _$$ExamsFailureImplCopyWith(
          _$ExamsFailureImpl value, $Res Function(_$ExamsFailureImpl) then) =
      __$$ExamsFailureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$ExamsFailureImplCopyWithImpl<$Res>
    extends _$ExamsStateCopyWithImpl<$Res, _$ExamsFailureImpl>
    implements _$$ExamsFailureImplCopyWith<$Res> {
  __$$ExamsFailureImplCopyWithImpl(
      _$ExamsFailureImpl _value, $Res Function(_$ExamsFailureImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$ExamsFailureImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ExamsFailureImpl implements _ExamsFailure {
  const _$ExamsFailureImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'ExamsState.examsFailure(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExamsFailureImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExamsFailureImplCopyWith<_$ExamsFailureImpl> get copyWith =>
      __$$ExamsFailureImplCopyWithImpl<_$ExamsFailureImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() examsLoading,
    required TResult Function(List<ExamsEntity> exams) examsSuccess,
    required TResult Function(String successMessage) successOnlyMessage,
    required TResult Function(String message) examsFailure,
  }) {
    return examsFailure(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? examsLoading,
    TResult? Function(List<ExamsEntity> exams)? examsSuccess,
    TResult? Function(String successMessage)? successOnlyMessage,
    TResult? Function(String message)? examsFailure,
  }) {
    return examsFailure?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? examsLoading,
    TResult Function(List<ExamsEntity> exams)? examsSuccess,
    TResult Function(String successMessage)? successOnlyMessage,
    TResult Function(String message)? examsFailure,
    required TResult orElse(),
  }) {
    if (examsFailure != null) {
      return examsFailure(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_ExamsLoading value) examsLoading,
    required TResult Function(ExamsSuccess value) examsSuccess,
    required TResult Function(_SuccessOnlyMessage value) successOnlyMessage,
    required TResult Function(_ExamsFailure value) examsFailure,
  }) {
    return examsFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_ExamsLoading value)? examsLoading,
    TResult? Function(ExamsSuccess value)? examsSuccess,
    TResult? Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult? Function(_ExamsFailure value)? examsFailure,
  }) {
    return examsFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_ExamsLoading value)? examsLoading,
    TResult Function(ExamsSuccess value)? examsSuccess,
    TResult Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult Function(_ExamsFailure value)? examsFailure,
    required TResult orElse(),
  }) {
    if (examsFailure != null) {
      return examsFailure(this);
    }
    return orElse();
  }
}

abstract class _ExamsFailure implements ExamsState {
  const factory _ExamsFailure(final String message) = _$ExamsFailureImpl;

  String get message;
  @JsonKey(ignore: true)
  _$$ExamsFailureImplCopyWith<_$ExamsFailureImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
