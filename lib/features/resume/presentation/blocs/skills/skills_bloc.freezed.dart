// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'skills_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SkillsEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getSkills,
    required TResult Function(SkillsEntity skillsEntity) addSkills,
    required TResult Function(SkillsEntity skillsEntity) updateSkills,
    required TResult Function(int id) deleteSkills,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getSkills,
    TResult? Function(SkillsEntity skillsEntity)? addSkills,
    TResult? Function(SkillsEntity skillsEntity)? updateSkills,
    TResult? Function(int id)? deleteSkills,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getSkills,
    TResult Function(SkillsEntity skillsEntity)? addSkills,
    TResult Function(SkillsEntity skillsEntity)? updateSkills,
    TResult Function(int id)? deleteSkills,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetSkills value) getSkills,
    required TResult Function(_AddSkills value) addSkills,
    required TResult Function(_UpdateSkills value) updateSkills,
    required TResult Function(_DeleteSkills value) deleteSkills,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetSkills value)? getSkills,
    TResult? Function(_AddSkills value)? addSkills,
    TResult? Function(_UpdateSkills value)? updateSkills,
    TResult? Function(_DeleteSkills value)? deleteSkills,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetSkills value)? getSkills,
    TResult Function(_AddSkills value)? addSkills,
    TResult Function(_UpdateSkills value)? updateSkills,
    TResult Function(_DeleteSkills value)? deleteSkills,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SkillsEventCopyWith<$Res> {
  factory $SkillsEventCopyWith(
          SkillsEvent value, $Res Function(SkillsEvent) then) =
      _$SkillsEventCopyWithImpl<$Res, SkillsEvent>;
}

/// @nodoc
class _$SkillsEventCopyWithImpl<$Res, $Val extends SkillsEvent>
    implements $SkillsEventCopyWith<$Res> {
  _$SkillsEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$GetSkillsImplCopyWith<$Res> {
  factory _$$GetSkillsImplCopyWith(
          _$GetSkillsImpl value, $Res Function(_$GetSkillsImpl) then) =
      __$$GetSkillsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetSkillsImplCopyWithImpl<$Res>
    extends _$SkillsEventCopyWithImpl<$Res, _$GetSkillsImpl>
    implements _$$GetSkillsImplCopyWith<$Res> {
  __$$GetSkillsImplCopyWithImpl(
      _$GetSkillsImpl _value, $Res Function(_$GetSkillsImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GetSkillsImpl implements _GetSkills {
  const _$GetSkillsImpl();

  @override
  String toString() {
    return 'SkillsEvent.getSkills()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetSkillsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getSkills,
    required TResult Function(SkillsEntity skillsEntity) addSkills,
    required TResult Function(SkillsEntity skillsEntity) updateSkills,
    required TResult Function(int id) deleteSkills,
  }) {
    return getSkills();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getSkills,
    TResult? Function(SkillsEntity skillsEntity)? addSkills,
    TResult? Function(SkillsEntity skillsEntity)? updateSkills,
    TResult? Function(int id)? deleteSkills,
  }) {
    return getSkills?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getSkills,
    TResult Function(SkillsEntity skillsEntity)? addSkills,
    TResult Function(SkillsEntity skillsEntity)? updateSkills,
    TResult Function(int id)? deleteSkills,
    required TResult orElse(),
  }) {
    if (getSkills != null) {
      return getSkills();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetSkills value) getSkills,
    required TResult Function(_AddSkills value) addSkills,
    required TResult Function(_UpdateSkills value) updateSkills,
    required TResult Function(_DeleteSkills value) deleteSkills,
  }) {
    return getSkills(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetSkills value)? getSkills,
    TResult? Function(_AddSkills value)? addSkills,
    TResult? Function(_UpdateSkills value)? updateSkills,
    TResult? Function(_DeleteSkills value)? deleteSkills,
  }) {
    return getSkills?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetSkills value)? getSkills,
    TResult Function(_AddSkills value)? addSkills,
    TResult Function(_UpdateSkills value)? updateSkills,
    TResult Function(_DeleteSkills value)? deleteSkills,
    required TResult orElse(),
  }) {
    if (getSkills != null) {
      return getSkills(this);
    }
    return orElse();
  }
}

abstract class _GetSkills implements SkillsEvent {
  const factory _GetSkills() = _$GetSkillsImpl;
}

/// @nodoc
abstract class _$$AddSkillsImplCopyWith<$Res> {
  factory _$$AddSkillsImplCopyWith(
          _$AddSkillsImpl value, $Res Function(_$AddSkillsImpl) then) =
      __$$AddSkillsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SkillsEntity skillsEntity});
}

/// @nodoc
class __$$AddSkillsImplCopyWithImpl<$Res>
    extends _$SkillsEventCopyWithImpl<$Res, _$AddSkillsImpl>
    implements _$$AddSkillsImplCopyWith<$Res> {
  __$$AddSkillsImplCopyWithImpl(
      _$AddSkillsImpl _value, $Res Function(_$AddSkillsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? skillsEntity = null,
  }) {
    return _then(_$AddSkillsImpl(
      null == skillsEntity
          ? _value.skillsEntity
          : skillsEntity // ignore: cast_nullable_to_non_nullable
              as SkillsEntity,
    ));
  }
}

/// @nodoc

class _$AddSkillsImpl implements _AddSkills {
  const _$AddSkillsImpl(this.skillsEntity);

  @override
  final SkillsEntity skillsEntity;

  @override
  String toString() {
    return 'SkillsEvent.addSkills(skillsEntity: $skillsEntity)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddSkillsImpl &&
            (identical(other.skillsEntity, skillsEntity) ||
                other.skillsEntity == skillsEntity));
  }

  @override
  int get hashCode => Object.hash(runtimeType, skillsEntity);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddSkillsImplCopyWith<_$AddSkillsImpl> get copyWith =>
      __$$AddSkillsImplCopyWithImpl<_$AddSkillsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getSkills,
    required TResult Function(SkillsEntity skillsEntity) addSkills,
    required TResult Function(SkillsEntity skillsEntity) updateSkills,
    required TResult Function(int id) deleteSkills,
  }) {
    return addSkills(skillsEntity);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getSkills,
    TResult? Function(SkillsEntity skillsEntity)? addSkills,
    TResult? Function(SkillsEntity skillsEntity)? updateSkills,
    TResult? Function(int id)? deleteSkills,
  }) {
    return addSkills?.call(skillsEntity);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getSkills,
    TResult Function(SkillsEntity skillsEntity)? addSkills,
    TResult Function(SkillsEntity skillsEntity)? updateSkills,
    TResult Function(int id)? deleteSkills,
    required TResult orElse(),
  }) {
    if (addSkills != null) {
      return addSkills(skillsEntity);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetSkills value) getSkills,
    required TResult Function(_AddSkills value) addSkills,
    required TResult Function(_UpdateSkills value) updateSkills,
    required TResult Function(_DeleteSkills value) deleteSkills,
  }) {
    return addSkills(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetSkills value)? getSkills,
    TResult? Function(_AddSkills value)? addSkills,
    TResult? Function(_UpdateSkills value)? updateSkills,
    TResult? Function(_DeleteSkills value)? deleteSkills,
  }) {
    return addSkills?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetSkills value)? getSkills,
    TResult Function(_AddSkills value)? addSkills,
    TResult Function(_UpdateSkills value)? updateSkills,
    TResult Function(_DeleteSkills value)? deleteSkills,
    required TResult orElse(),
  }) {
    if (addSkills != null) {
      return addSkills(this);
    }
    return orElse();
  }
}

abstract class _AddSkills implements SkillsEvent {
  const factory _AddSkills(final SkillsEntity skillsEntity) = _$AddSkillsImpl;

  SkillsEntity get skillsEntity;
  @JsonKey(ignore: true)
  _$$AddSkillsImplCopyWith<_$AddSkillsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateSkillsImplCopyWith<$Res> {
  factory _$$UpdateSkillsImplCopyWith(
          _$UpdateSkillsImpl value, $Res Function(_$UpdateSkillsImpl) then) =
      __$$UpdateSkillsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SkillsEntity skillsEntity});
}

/// @nodoc
class __$$UpdateSkillsImplCopyWithImpl<$Res>
    extends _$SkillsEventCopyWithImpl<$Res, _$UpdateSkillsImpl>
    implements _$$UpdateSkillsImplCopyWith<$Res> {
  __$$UpdateSkillsImplCopyWithImpl(
      _$UpdateSkillsImpl _value, $Res Function(_$UpdateSkillsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? skillsEntity = null,
  }) {
    return _then(_$UpdateSkillsImpl(
      null == skillsEntity
          ? _value.skillsEntity
          : skillsEntity // ignore: cast_nullable_to_non_nullable
              as SkillsEntity,
    ));
  }
}

/// @nodoc

class _$UpdateSkillsImpl implements _UpdateSkills {
  const _$UpdateSkillsImpl(this.skillsEntity);

  @override
  final SkillsEntity skillsEntity;

  @override
  String toString() {
    return 'SkillsEvent.updateSkills(skillsEntity: $skillsEntity)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateSkillsImpl &&
            (identical(other.skillsEntity, skillsEntity) ||
                other.skillsEntity == skillsEntity));
  }

  @override
  int get hashCode => Object.hash(runtimeType, skillsEntity);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateSkillsImplCopyWith<_$UpdateSkillsImpl> get copyWith =>
      __$$UpdateSkillsImplCopyWithImpl<_$UpdateSkillsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getSkills,
    required TResult Function(SkillsEntity skillsEntity) addSkills,
    required TResult Function(SkillsEntity skillsEntity) updateSkills,
    required TResult Function(int id) deleteSkills,
  }) {
    return updateSkills(skillsEntity);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getSkills,
    TResult? Function(SkillsEntity skillsEntity)? addSkills,
    TResult? Function(SkillsEntity skillsEntity)? updateSkills,
    TResult? Function(int id)? deleteSkills,
  }) {
    return updateSkills?.call(skillsEntity);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getSkills,
    TResult Function(SkillsEntity skillsEntity)? addSkills,
    TResult Function(SkillsEntity skillsEntity)? updateSkills,
    TResult Function(int id)? deleteSkills,
    required TResult orElse(),
  }) {
    if (updateSkills != null) {
      return updateSkills(skillsEntity);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetSkills value) getSkills,
    required TResult Function(_AddSkills value) addSkills,
    required TResult Function(_UpdateSkills value) updateSkills,
    required TResult Function(_DeleteSkills value) deleteSkills,
  }) {
    return updateSkills(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetSkills value)? getSkills,
    TResult? Function(_AddSkills value)? addSkills,
    TResult? Function(_UpdateSkills value)? updateSkills,
    TResult? Function(_DeleteSkills value)? deleteSkills,
  }) {
    return updateSkills?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetSkills value)? getSkills,
    TResult Function(_AddSkills value)? addSkills,
    TResult Function(_UpdateSkills value)? updateSkills,
    TResult Function(_DeleteSkills value)? deleteSkills,
    required TResult orElse(),
  }) {
    if (updateSkills != null) {
      return updateSkills(this);
    }
    return orElse();
  }
}

abstract class _UpdateSkills implements SkillsEvent {
  const factory _UpdateSkills(final SkillsEntity skillsEntity) =
      _$UpdateSkillsImpl;

  SkillsEntity get skillsEntity;
  @JsonKey(ignore: true)
  _$$UpdateSkillsImplCopyWith<_$UpdateSkillsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DeleteSkillsImplCopyWith<$Res> {
  factory _$$DeleteSkillsImplCopyWith(
          _$DeleteSkillsImpl value, $Res Function(_$DeleteSkillsImpl) then) =
      __$$DeleteSkillsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int id});
}

/// @nodoc
class __$$DeleteSkillsImplCopyWithImpl<$Res>
    extends _$SkillsEventCopyWithImpl<$Res, _$DeleteSkillsImpl>
    implements _$$DeleteSkillsImplCopyWith<$Res> {
  __$$DeleteSkillsImplCopyWithImpl(
      _$DeleteSkillsImpl _value, $Res Function(_$DeleteSkillsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
  }) {
    return _then(_$DeleteSkillsImpl(
      null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$DeleteSkillsImpl implements _DeleteSkills {
  const _$DeleteSkillsImpl(this.id);

  @override
  final int id;

  @override
  String toString() {
    return 'SkillsEvent.deleteSkills(id: $id)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteSkillsImpl &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteSkillsImplCopyWith<_$DeleteSkillsImpl> get copyWith =>
      __$$DeleteSkillsImplCopyWithImpl<_$DeleteSkillsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getSkills,
    required TResult Function(SkillsEntity skillsEntity) addSkills,
    required TResult Function(SkillsEntity skillsEntity) updateSkills,
    required TResult Function(int id) deleteSkills,
  }) {
    return deleteSkills(id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getSkills,
    TResult? Function(SkillsEntity skillsEntity)? addSkills,
    TResult? Function(SkillsEntity skillsEntity)? updateSkills,
    TResult? Function(int id)? deleteSkills,
  }) {
    return deleteSkills?.call(id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getSkills,
    TResult Function(SkillsEntity skillsEntity)? addSkills,
    TResult Function(SkillsEntity skillsEntity)? updateSkills,
    TResult Function(int id)? deleteSkills,
    required TResult orElse(),
  }) {
    if (deleteSkills != null) {
      return deleteSkills(id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetSkills value) getSkills,
    required TResult Function(_AddSkills value) addSkills,
    required TResult Function(_UpdateSkills value) updateSkills,
    required TResult Function(_DeleteSkills value) deleteSkills,
  }) {
    return deleteSkills(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetSkills value)? getSkills,
    TResult? Function(_AddSkills value)? addSkills,
    TResult? Function(_UpdateSkills value)? updateSkills,
    TResult? Function(_DeleteSkills value)? deleteSkills,
  }) {
    return deleteSkills?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetSkills value)? getSkills,
    TResult Function(_AddSkills value)? addSkills,
    TResult Function(_UpdateSkills value)? updateSkills,
    TResult Function(_DeleteSkills value)? deleteSkills,
    required TResult orElse(),
  }) {
    if (deleteSkills != null) {
      return deleteSkills(this);
    }
    return orElse();
  }
}

abstract class _DeleteSkills implements SkillsEvent {
  const factory _DeleteSkills(final int id) = _$DeleteSkillsImpl;

  int get id;
  @JsonKey(ignore: true)
  _$$DeleteSkillsImplCopyWith<_$DeleteSkillsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SkillsState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() skillsLoading,
    required TResult Function(List<SkillsEntity> skills) skillsSuccess,
    required TResult Function(String successMessage) successOnlyMessage,
    required TResult Function(String message) skillsFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? skillsLoading,
    TResult? Function(List<SkillsEntity> skills)? skillsSuccess,
    TResult? Function(String successMessage)? successOnlyMessage,
    TResult? Function(String message)? skillsFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? skillsLoading,
    TResult Function(List<SkillsEntity> skills)? skillsSuccess,
    TResult Function(String successMessage)? successOnlyMessage,
    TResult Function(String message)? skillsFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SkillsLoading value) skillsLoading,
    required TResult Function(SkillsSuccess value) skillsSuccess,
    required TResult Function(_SuccessOnlyMessage value) successOnlyMessage,
    required TResult Function(_SkillsFailure value) skillsFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_SkillsLoading value)? skillsLoading,
    TResult? Function(SkillsSuccess value)? skillsSuccess,
    TResult? Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult? Function(_SkillsFailure value)? skillsFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SkillsLoading value)? skillsLoading,
    TResult Function(SkillsSuccess value)? skillsSuccess,
    TResult Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult Function(_SkillsFailure value)? skillsFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SkillsStateCopyWith<$Res> {
  factory $SkillsStateCopyWith(
          SkillsState value, $Res Function(SkillsState) then) =
      _$SkillsStateCopyWithImpl<$Res, SkillsState>;
}

/// @nodoc
class _$SkillsStateCopyWithImpl<$Res, $Val extends SkillsState>
    implements $SkillsStateCopyWith<$Res> {
  _$SkillsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$SkillsStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'SkillsState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() skillsLoading,
    required TResult Function(List<SkillsEntity> skills) skillsSuccess,
    required TResult Function(String successMessage) successOnlyMessage,
    required TResult Function(String message) skillsFailure,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? skillsLoading,
    TResult? Function(List<SkillsEntity> skills)? skillsSuccess,
    TResult? Function(String successMessage)? successOnlyMessage,
    TResult? Function(String message)? skillsFailure,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? skillsLoading,
    TResult Function(List<SkillsEntity> skills)? skillsSuccess,
    TResult Function(String successMessage)? successOnlyMessage,
    TResult Function(String message)? skillsFailure,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SkillsLoading value) skillsLoading,
    required TResult Function(SkillsSuccess value) skillsSuccess,
    required TResult Function(_SuccessOnlyMessage value) successOnlyMessage,
    required TResult Function(_SkillsFailure value) skillsFailure,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_SkillsLoading value)? skillsLoading,
    TResult? Function(SkillsSuccess value)? skillsSuccess,
    TResult? Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult? Function(_SkillsFailure value)? skillsFailure,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SkillsLoading value)? skillsLoading,
    TResult Function(SkillsSuccess value)? skillsSuccess,
    TResult Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult Function(_SkillsFailure value)? skillsFailure,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements SkillsState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$SkillsLoadingImplCopyWith<$Res> {
  factory _$$SkillsLoadingImplCopyWith(
          _$SkillsLoadingImpl value, $Res Function(_$SkillsLoadingImpl) then) =
      __$$SkillsLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SkillsLoadingImplCopyWithImpl<$Res>
    extends _$SkillsStateCopyWithImpl<$Res, _$SkillsLoadingImpl>
    implements _$$SkillsLoadingImplCopyWith<$Res> {
  __$$SkillsLoadingImplCopyWithImpl(
      _$SkillsLoadingImpl _value, $Res Function(_$SkillsLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SkillsLoadingImpl implements _SkillsLoading {
  const _$SkillsLoadingImpl();

  @override
  String toString() {
    return 'SkillsState.skillsLoading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SkillsLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() skillsLoading,
    required TResult Function(List<SkillsEntity> skills) skillsSuccess,
    required TResult Function(String successMessage) successOnlyMessage,
    required TResult Function(String message) skillsFailure,
  }) {
    return skillsLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? skillsLoading,
    TResult? Function(List<SkillsEntity> skills)? skillsSuccess,
    TResult? Function(String successMessage)? successOnlyMessage,
    TResult? Function(String message)? skillsFailure,
  }) {
    return skillsLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? skillsLoading,
    TResult Function(List<SkillsEntity> skills)? skillsSuccess,
    TResult Function(String successMessage)? successOnlyMessage,
    TResult Function(String message)? skillsFailure,
    required TResult orElse(),
  }) {
    if (skillsLoading != null) {
      return skillsLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SkillsLoading value) skillsLoading,
    required TResult Function(SkillsSuccess value) skillsSuccess,
    required TResult Function(_SuccessOnlyMessage value) successOnlyMessage,
    required TResult Function(_SkillsFailure value) skillsFailure,
  }) {
    return skillsLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_SkillsLoading value)? skillsLoading,
    TResult? Function(SkillsSuccess value)? skillsSuccess,
    TResult? Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult? Function(_SkillsFailure value)? skillsFailure,
  }) {
    return skillsLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SkillsLoading value)? skillsLoading,
    TResult Function(SkillsSuccess value)? skillsSuccess,
    TResult Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult Function(_SkillsFailure value)? skillsFailure,
    required TResult orElse(),
  }) {
    if (skillsLoading != null) {
      return skillsLoading(this);
    }
    return orElse();
  }
}

abstract class _SkillsLoading implements SkillsState {
  const factory _SkillsLoading() = _$SkillsLoadingImpl;
}

/// @nodoc
abstract class _$$SkillsSuccessImplCopyWith<$Res> {
  factory _$$SkillsSuccessImplCopyWith(
          _$SkillsSuccessImpl value, $Res Function(_$SkillsSuccessImpl) then) =
      __$$SkillsSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<SkillsEntity> skills});
}

/// @nodoc
class __$$SkillsSuccessImplCopyWithImpl<$Res>
    extends _$SkillsStateCopyWithImpl<$Res, _$SkillsSuccessImpl>
    implements _$$SkillsSuccessImplCopyWith<$Res> {
  __$$SkillsSuccessImplCopyWithImpl(
      _$SkillsSuccessImpl _value, $Res Function(_$SkillsSuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? skills = null,
  }) {
    return _then(_$SkillsSuccessImpl(
      null == skills
          ? _value._skills
          : skills // ignore: cast_nullable_to_non_nullable
              as List<SkillsEntity>,
    ));
  }
}

/// @nodoc

class _$SkillsSuccessImpl implements SkillsSuccess {
  const _$SkillsSuccessImpl(final List<SkillsEntity> skills) : _skills = skills;

  final List<SkillsEntity> _skills;
  @override
  List<SkillsEntity> get skills {
    if (_skills is EqualUnmodifiableListView) return _skills;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_skills);
  }

  @override
  String toString() {
    return 'SkillsState.skillsSuccess(skills: $skills)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SkillsSuccessImpl &&
            const DeepCollectionEquality().equals(other._skills, _skills));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_skills));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SkillsSuccessImplCopyWith<_$SkillsSuccessImpl> get copyWith =>
      __$$SkillsSuccessImplCopyWithImpl<_$SkillsSuccessImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() skillsLoading,
    required TResult Function(List<SkillsEntity> skills) skillsSuccess,
    required TResult Function(String successMessage) successOnlyMessage,
    required TResult Function(String message) skillsFailure,
  }) {
    return skillsSuccess(skills);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? skillsLoading,
    TResult? Function(List<SkillsEntity> skills)? skillsSuccess,
    TResult? Function(String successMessage)? successOnlyMessage,
    TResult? Function(String message)? skillsFailure,
  }) {
    return skillsSuccess?.call(skills);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? skillsLoading,
    TResult Function(List<SkillsEntity> skills)? skillsSuccess,
    TResult Function(String successMessage)? successOnlyMessage,
    TResult Function(String message)? skillsFailure,
    required TResult orElse(),
  }) {
    if (skillsSuccess != null) {
      return skillsSuccess(skills);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SkillsLoading value) skillsLoading,
    required TResult Function(SkillsSuccess value) skillsSuccess,
    required TResult Function(_SuccessOnlyMessage value) successOnlyMessage,
    required TResult Function(_SkillsFailure value) skillsFailure,
  }) {
    return skillsSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_SkillsLoading value)? skillsLoading,
    TResult? Function(SkillsSuccess value)? skillsSuccess,
    TResult? Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult? Function(_SkillsFailure value)? skillsFailure,
  }) {
    return skillsSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SkillsLoading value)? skillsLoading,
    TResult Function(SkillsSuccess value)? skillsSuccess,
    TResult Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult Function(_SkillsFailure value)? skillsFailure,
    required TResult orElse(),
  }) {
    if (skillsSuccess != null) {
      return skillsSuccess(this);
    }
    return orElse();
  }
}

abstract class SkillsSuccess implements SkillsState {
  const factory SkillsSuccess(final List<SkillsEntity> skills) =
      _$SkillsSuccessImpl;

  List<SkillsEntity> get skills;
  @JsonKey(ignore: true)
  _$$SkillsSuccessImplCopyWith<_$SkillsSuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SuccessOnlyMessageImplCopyWith<$Res> {
  factory _$$SuccessOnlyMessageImplCopyWith(_$SuccessOnlyMessageImpl value,
          $Res Function(_$SuccessOnlyMessageImpl) then) =
      __$$SuccessOnlyMessageImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String successMessage});
}

/// @nodoc
class __$$SuccessOnlyMessageImplCopyWithImpl<$Res>
    extends _$SkillsStateCopyWithImpl<$Res, _$SuccessOnlyMessageImpl>
    implements _$$SuccessOnlyMessageImplCopyWith<$Res> {
  __$$SuccessOnlyMessageImplCopyWithImpl(_$SuccessOnlyMessageImpl _value,
      $Res Function(_$SuccessOnlyMessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? successMessage = null,
  }) {
    return _then(_$SuccessOnlyMessageImpl(
      null == successMessage
          ? _value.successMessage
          : successMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SuccessOnlyMessageImpl implements _SuccessOnlyMessage {
  const _$SuccessOnlyMessageImpl(this.successMessage);

  @override
  final String successMessage;

  @override
  String toString() {
    return 'SkillsState.successOnlyMessage(successMessage: $successMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuccessOnlyMessageImpl &&
            (identical(other.successMessage, successMessage) ||
                other.successMessage == successMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, successMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SuccessOnlyMessageImplCopyWith<_$SuccessOnlyMessageImpl> get copyWith =>
      __$$SuccessOnlyMessageImplCopyWithImpl<_$SuccessOnlyMessageImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() skillsLoading,
    required TResult Function(List<SkillsEntity> skills) skillsSuccess,
    required TResult Function(String successMessage) successOnlyMessage,
    required TResult Function(String message) skillsFailure,
  }) {
    return successOnlyMessage(successMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? skillsLoading,
    TResult? Function(List<SkillsEntity> skills)? skillsSuccess,
    TResult? Function(String successMessage)? successOnlyMessage,
    TResult? Function(String message)? skillsFailure,
  }) {
    return successOnlyMessage?.call(successMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? skillsLoading,
    TResult Function(List<SkillsEntity> skills)? skillsSuccess,
    TResult Function(String successMessage)? successOnlyMessage,
    TResult Function(String message)? skillsFailure,
    required TResult orElse(),
  }) {
    if (successOnlyMessage != null) {
      return successOnlyMessage(successMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SkillsLoading value) skillsLoading,
    required TResult Function(SkillsSuccess value) skillsSuccess,
    required TResult Function(_SuccessOnlyMessage value) successOnlyMessage,
    required TResult Function(_SkillsFailure value) skillsFailure,
  }) {
    return successOnlyMessage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_SkillsLoading value)? skillsLoading,
    TResult? Function(SkillsSuccess value)? skillsSuccess,
    TResult? Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult? Function(_SkillsFailure value)? skillsFailure,
  }) {
    return successOnlyMessage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SkillsLoading value)? skillsLoading,
    TResult Function(SkillsSuccess value)? skillsSuccess,
    TResult Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult Function(_SkillsFailure value)? skillsFailure,
    required TResult orElse(),
  }) {
    if (successOnlyMessage != null) {
      return successOnlyMessage(this);
    }
    return orElse();
  }
}

abstract class _SuccessOnlyMessage implements SkillsState {
  const factory _SuccessOnlyMessage(final String successMessage) =
      _$SuccessOnlyMessageImpl;

  String get successMessage;
  @JsonKey(ignore: true)
  _$$SuccessOnlyMessageImplCopyWith<_$SuccessOnlyMessageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SkillsFailureImplCopyWith<$Res> {
  factory _$$SkillsFailureImplCopyWith(
          _$SkillsFailureImpl value, $Res Function(_$SkillsFailureImpl) then) =
      __$$SkillsFailureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$SkillsFailureImplCopyWithImpl<$Res>
    extends _$SkillsStateCopyWithImpl<$Res, _$SkillsFailureImpl>
    implements _$$SkillsFailureImplCopyWith<$Res> {
  __$$SkillsFailureImplCopyWithImpl(
      _$SkillsFailureImpl _value, $Res Function(_$SkillsFailureImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$SkillsFailureImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SkillsFailureImpl implements _SkillsFailure {
  const _$SkillsFailureImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'SkillsState.skillsFailure(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SkillsFailureImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SkillsFailureImplCopyWith<_$SkillsFailureImpl> get copyWith =>
      __$$SkillsFailureImplCopyWithImpl<_$SkillsFailureImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() skillsLoading,
    required TResult Function(List<SkillsEntity> skills) skillsSuccess,
    required TResult Function(String successMessage) successOnlyMessage,
    required TResult Function(String message) skillsFailure,
  }) {
    return skillsFailure(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? skillsLoading,
    TResult? Function(List<SkillsEntity> skills)? skillsSuccess,
    TResult? Function(String successMessage)? successOnlyMessage,
    TResult? Function(String message)? skillsFailure,
  }) {
    return skillsFailure?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? skillsLoading,
    TResult Function(List<SkillsEntity> skills)? skillsSuccess,
    TResult Function(String successMessage)? successOnlyMessage,
    TResult Function(String message)? skillsFailure,
    required TResult orElse(),
  }) {
    if (skillsFailure != null) {
      return skillsFailure(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SkillsLoading value) skillsLoading,
    required TResult Function(SkillsSuccess value) skillsSuccess,
    required TResult Function(_SuccessOnlyMessage value) successOnlyMessage,
    required TResult Function(_SkillsFailure value) skillsFailure,
  }) {
    return skillsFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_SkillsLoading value)? skillsLoading,
    TResult? Function(SkillsSuccess value)? skillsSuccess,
    TResult? Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult? Function(_SkillsFailure value)? skillsFailure,
  }) {
    return skillsFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SkillsLoading value)? skillsLoading,
    TResult Function(SkillsSuccess value)? skillsSuccess,
    TResult Function(_SuccessOnlyMessage value)? successOnlyMessage,
    TResult Function(_SkillsFailure value)? skillsFailure,
    required TResult orElse(),
  }) {
    if (skillsFailure != null) {
      return skillsFailure(this);
    }
    return orElse();
  }
}

abstract class _SkillsFailure implements SkillsState {
  const factory _SkillsFailure(final String message) = _$SkillsFailureImpl;

  String get message;
  @JsonKey(ignore: true)
  _$$SkillsFailureImplCopyWith<_$SkillsFailureImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
